/******************************************************************************
 * Version History:
 * v0.0.0	2024-03-24	Craig Comberbach
 * 	Testing performed with Ceedling 0.32.0-9b8d8a9 pre-release and GCC 13.2.0
 *	First version - Generated by AI (ChatGPT4)
 ******************************************************************************/
/************Header Files*************/
#include "BDB_ButtonDebounce.h"

/********Semantic Versioning**********/
#if BUTTON_DEBOUNCE_MAJOR != 0
	#error "ButtonDebounce library major revision update is available"
#elif BUTTON_DEBOUNCE_MINOR != 0
	#error "ButtonDebounce library minor revision update is available"
#elif BUTTON_DEBOUNCE_PATCH != 0
	#error "ButtonDebounce library patch revision update is available"
#endif
/***********Magic Numbers*************/
/************Enumerations*************/
/**********Type Definitions***********/
/*************Structures**************/
/**********Global Variables***********/
/*********Object Definition***********/
struct Switch
{
	uint32_t debounceDelay;
	uint32_t holdDelay;
	uint32_t lastStateChangeTime;
	SwitchState state;
	bool lastInput;
	SwitchStateCallback callback;
};
struct Switch selves[NUMBER_OF_BUTTON_DEBOUNCE_OBJECTS];

/*****Local Function Prototypes*******/
//State transition functions
void Transition_ToPressed(BDB_Object_t *sw, uint32_t currentTime);
void Transition_ToReleased(BDB_Object_t *sw, uint32_t currentTime);
void Transition_ToHeld(BDB_Object_t *sw, uint32_t currentTime);
void Transition_ToUnpressed(BDB_Object_t *sw, uint32_t currentTime);

/*********Main Body Of Code***********/
void Switch_Init(BDB_Object_t *sw, uint32_t debounceDelay, uint32_t holdDelay, SwitchStateCallback callback)
{
	sw->debounceDelay = debounceDelay;
	sw->holdDelay = holdDelay;
	sw->lastStateChangeTime = 0;
	sw->state = SWITCH_UNPRESSED;
	sw->lastInput = false;
	sw->callback = callback;
}

void Transition_ToPressed(BDB_Object_t *sw, uint32_t currentTime)
{
	sw->state = SWITCH_PRESSED;
	sw->lastStateChangeTime = currentTime;
	if(sw->callback)
	{
		sw->callback(sw - sw, SWITCH_PRESSED);
	}
}

void Transition_ToReleased(BDB_Object_t *sw, uint32_t currentTime)
{
	sw->state = SWITCH_RELEASED;
	sw->lastStateChangeTime = currentTime;
	if(sw->callback)
	{
		sw->callback(sw - sw, SWITCH_RELEASED);
	}
}

void Transition_ToHeld(BDB_Object_t *sw, uint32_t currentTime)
{
	sw->state = SWITCH_HELD;
	if(sw->callback)
	{
		sw->callback(sw - sw, SWITCH_HELD);
	}
}

void Transition_ToUnpressed(BDB_Object_t *sw, uint32_t currentTime)
{
	sw->state = SWITCH_UNPRESSED;
	sw->lastStateChangeTime = currentTime;
	if(sw->callback)
	{
		sw->callback(sw - sw, SWITCH_UNPRESSED);
	}
}

void Switch_Update(BDB_Object_t *sw, bool currentInput, uint32_t currentTime)
{
	bool debounceTimeElapsed = (currentTime - sw->lastStateChangeTime) > sw->debounceDelay;
	if(currentInput != sw->lastInput)
	{
		sw->lastStateChangeTime = currentTime;
	}
	sw->lastInput = currentInput;

	switch(sw->state)
	{
		case SWITCH_UNPRESSED:
			if(currentInput && debounceTimeElapsed)
			{
				Transition_ToPressed(sw, currentTime);
			}
			break;
		case SWITCH_PRESSED:
			if(!currentInput && debounceTimeElapsed)
			{
				Transition_ToReleased(sw, currentTime);
			}
			else if(currentInput && (currentTime - sw->lastStateChangeTime) > sw->holdDelay)
			{
				Transition_ToHeld(sw, currentTime);
			}
			break;
		case SWITCH_HELD:
			if(!currentInput && debounceTimeElapsed)
			{
				Transition_ToReleased(sw, currentTime);
			}
			break;
		case SWITCH_RELEASED:
			if(currentInput && debounceTimeElapsed)
			{
				Transition_ToPressed(sw, currentTime);
			}
			else if(!currentInput && debounceTimeElapsed)
			{
				Transition_ToUnpressed(sw, currentTime);
			}
			break;
	}
}

void Process_Switches(BDB_Object_t *switchArray, uint8_t numSwitches, bool *inputs, uint32_t currentTime)
{
	for(uint8_t i = 0; i < numSwitches; i++)
	{
		Switch_Update(&switchArray[i], inputs[i], currentTime);
	}
}

#ifdef ENABLE_BUTTON_DEBOUNCE_TEST_WRAPPERS
void TestSetBDB_Selves_debounceDelay(BDB_ObjectList_t ID, uint32_t NewValue);
uint32_t TestGetBDB_Selves_debounceDelay(BDB_ObjectList_t ID);
void TestSetBDB_Selves_holdDelay(BDB_ObjectList_t ID, uint32_t NewValue);
uint32_t TestGetBDB_Selves_holdDelay(BDB_ObjectList_t ID);
void TestSetBDB_Selves_lastStateChangeTime(BDB_ObjectList_t ID, uint32_t NewValue);
uint32_t TestGetBDB_Selves_lastStateChangeTime(BDB_ObjectList_t ID);
void TestSetBDB_Selves_state(BDB_ObjectList_t ID, SwitchState NewValue);
SwitchState TestGetBDB_Selves_state(BDB_ObjectList_t ID);
void TestSetBDB_Selves_lastInput(BDB_ObjectList_t ID, bool NewValue);
bool TestGetBDB_Selves_lastInput(BDB_ObjectList_t ID);
void TestSetBDB_Selves_callback(BDB_ObjectList_t ID, SwitchStateCallback NewValue);
SwitchStateCallback TestGetBDB_Selves_callback(BDB_ObjectList_t ID);

void TestSetBDB_Selves_debounceDelay(BDB_ObjectList_t ID, uint32_t NewValue)
{
	selves[ID].debounceDelay = NewValue;
	return;
}

uint32_t TestGetBDB_Selves_debounceDelay(BDB_ObjectList_t ID)
{
	return selves[ID].debounceDelay;
}

void TestSetBDB_Selves_holdDelay(BDB_ObjectList_t ID, uint32_t NewValue)
{
	selves[ID].holdDelay = NewValue;
	return;
}

uint32_t TestGetBDB_Selves_holdDelay(BDB_ObjectList_t ID)
{
	return selves[ID].holdDelay;
}

void TestSetBDB_Selves_lastStateChangeTime(BDB_ObjectList_t ID, uint32_t NewValue)
{
	selves[ID].lastStateChangeTime = NewValue;
	return;
}

uint32_t TestGetBDB_Selves_lastStateChangeTime(BDB_ObjectList_t ID)
{
	return selves[ID].lastStateChangeTime;
}

void TestSetBDB_Selves_state(BDB_ObjectList_t ID, SwitchState NewValue)
{
	selves[ID].state = NewValue;
	return;
}

SwitchState TestGetBDB_Selves_state(BDB_ObjectList_t ID)
{
	return selves[ID].state;
}

void TestSetBDB_Selves_lastInput(BDB_ObjectList_t ID, bool NewValue)
{
	selves[ID].lastInput = NewValue;
	return;
}

bool TestGetBDB_Selves_lastInput(BDB_ObjectList_t ID)
{
	return selves[ID].lastInput;
}

void TestSetBDB_Selves_callback(BDB_ObjectList_t ID, SwitchStateCallback NewValue)
{
	selves[ID].callback = NewValue;
	return;
}

SwitchStateCallback TestGetBDB_Selves_callback(BDB_ObjectList_t ID)
{
	return selves[ID].callback;
}

#endif
